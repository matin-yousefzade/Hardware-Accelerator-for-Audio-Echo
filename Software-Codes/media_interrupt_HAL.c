#include "globals.h"

/* these globals are written by interrupt service routines; we have to declare 
 * these as volatile to avoid the compiler caching their values in registers */
extern volatile int buf_index_record, buf_index_play, record_flag, status;		// used for audio_ISR
extern volatile unsigned char byte1, byte2, byte3;	/* modified by PS/2 interrupt service routine */
unsigned char b1, b2, b3;							// temporary bytes
extern volatile int n, f;							// used for PS2_ISR
extern volatile int timeout;						// used to synchronize with the timer
extern struct alt_up_dev up_dev;					/* pointer to struct that holds pointers to open devices */
extern volatile int r_buf[BUF_SIZE], l_buf[BUF_SIZE];
unsigned int average[N];
volatile unsigned long long int sum[N];
short screen_color = 0x0CCC; short average_bar_color = 0xF800; short movement_bar_color = 0xFFE0;

/* function prototypes */
void interval_timer_ISR(void *, unsigned int);
void pushbutton_ISR(void *, unsigned int);
void audio_ISR(void *, unsigned int);
void PS2_ISR(void *, unsigned int);
void HEX_LEDR_PS2(struct alt_up_dev *, unsigned char, unsigned char, unsigned char);
void calc_sum(void);
void display_average(alt_up_pixel_buffer_dma_dev *);
void display_movement(alt_up_pixel_buffer_dma_dev *);

/********************************************************************************
 * This program demonstrates use of the media ports in the DE2 Media Computer
 *
 * It performs the following: 
 *  	1. records audio for about 10 seconds when an interrupt is generated by
 *  	   pressing KEY[1]. LEDG[0] is lit while recording. Audio recording is 
 *  	   controlled by using interrupts
 * 	2. plays the recorded audio when an interrupt is generated by pressing
 * 	   KEY[2]. LEDG[1] is lit while playing. Audio playback is controlled by 
 * 	   using interrupts
 * 	3. Draws a blue box on the VGA display, and places a text string inside
 * 	   the box. Also, moves the word ALTERA around the display, "bouncing" off
 * 	   the blue box and screen edges
 * 	4. Shows a text message on the LCD display, and scrolls the message
 * 	5. Displays the last three bytes of data received from the PS/2 port 
 * 	   on the HEX displays on the DE2 board. The PS/2 port is handled using 
 * 	   interrupts
 * 	6. The speed of scrolling the LCD display and of refreshing the VGA screen
 * 	   are controlled by interrupts from the interval timer
********************************************************************************/
int main(void)
{
	/* declare device driver pointers for devices */
	alt_up_parallel_port_dev *KEY_dev;
	alt_up_parallel_port_dev *green_LEDs_dev;
	alt_up_parallel_port_dev *red_LEDs_dev;
	alt_up_ps2_dev *PS2_dev;
	alt_up_character_lcd_dev *lcd_dev;
	alt_up_audio_dev *audio_dev;
	alt_up_char_buffer_dev *char_buffer_dev;
	alt_up_pixel_buffer_dma_dev *pixel_buffer_dev;
	/* declare volatile pointer for interval timer, which does not have HAL functions */
	volatile int * interval_timer_ptr = (int *) 0x10002000;	// internal timer base address

	/* initialize some variables */
	record_flag = 0;						// initialize record state
	byte1 = 0; byte2 = 0; byte3 = 0;		// used to hold PS/2 data
	n = 0; f = 0;							// initialize mouse state
	timeout = 0;							// synchronize with the timer

	/* these variables are used for a blue box and a "bouncing" ALTERA on the VGA screen */
	int x11 = 40; int x12 = 140; int y11 = 10; int y12 = 50;
	int x21 = 180; int x22 = 280; int y21 = 10; int y22 = 50;
	int mouse_x = 160; int mouse_y = 36; int old_mouse_x; int old_mouse_y;
	int screen_x = 319; int screen_y = 239; int dx; int dy; int W = 3; int C = 1; int i;
	short box_color = 0x187F; short line_color = 0xFFFF; short mouse_color = 0xFFFF; short old_mouse_color;
	unsigned char PS2_read1, PS2_read2, PS2_read3;

	/* set the interval timer period for scrolling the HEX displays */
	int counter = 0x960000;				// 1/(50 MHz) x (0x960000) ~= 200 msec
	*(interval_timer_ptr + 0x2) = (counter & 0xFFFF);
	*(interval_timer_ptr + 0x3) = (counter >> 16) & 0xFFFF;

	/* start interval timer, enable its interrupts */
	*(interval_timer_ptr + 1) = 0x7;	// STOP = 0, START = 1, CONT = 1, ITO = 1 
	
	// open the pushbutton KEY parallel port
	KEY_dev = alt_up_parallel_port_open_dev ("/dev/Pushbuttons");
	if ( KEY_dev == NULL)
	{
		alt_printf ("Error: could not open pushbutton KEY device\n");
		return -1;
	}
	else
	{
		alt_printf ("Opened pushbutton KEY device\n");
		up_dev.KEY_dev = KEY_dev;	// store for use by ISRs
	}
	/* write to the pushbutton interrupt mask register, and set 3 mask bits to 1 
	 * (bit 0 is Nios II reset) */
	alt_up_parallel_port_set_interrupt_mask (KEY_dev, 0xE);

	// open the green LEDs parallel port
	green_LEDs_dev = alt_up_parallel_port_open_dev ("/dev/Green_LEDs");
	if ( green_LEDs_dev == NULL)
	{
		alt_printf ("Error: could not open green LEDs device\n");
		return -1;
	}
	else
	{
		alt_printf ("Opened green LEDs device\n");
		up_dev.green_LEDs_dev = green_LEDs_dev;	// store for use by ISRs
	}

	// open the red LEDs parallel port
	red_LEDs_dev = alt_up_parallel_port_open_dev ("/dev/Red_LEDs");
	if ( red_LEDs_dev == NULL)
	{
		alt_printf ("Error: could not open red LEDs device\n");
		return -1;
	}
	else
	{
		alt_printf ("Opened red LEDs device\n");
		up_dev.red_LEDs_dev = red_LEDs_dev;	// store for use by ISRs
	}

	// open the PS2 port
	PS2_dev = alt_up_ps2_open_dev ("/dev/PS2_Port");
	if ( PS2_dev == NULL)
	{
		alt_printf ("Error: could not open PS2 device\n");
		return -1;
	}
	else
	{
		alt_printf ("Opened PS2 device\n");
		up_dev.PS2_dev = PS2_dev;	// store for use by ISRs
	}

	// reset the PS2 port
	(void) alt_up_ps2_write_data_byte_with_ack (PS2_dev, 0xFF);
	alt_up_ps2_read_data_byte_timeout (PS2_dev, &PS2_read1);
	alt_up_ps2_read_data_byte_timeout (PS2_dev, &PS2_read2);
	alt_up_ps2_read_data_byte_timeout (PS2_dev, &PS2_read3);
	if (PS2_read1 == 0xFA) {
		if (PS2_read2 == 0xAA && PS2_read3 == 0x00)
			alt_printf ("Reseted the PS2 port\n");

		else {
			alt_printf ("Error: could not reset the PS2 port\n");
			return -1;
		}
	}

	// enable interrupts from PS/2 port
	alt_up_ps2_enable_read_interrupt (PS2_dev);
	(void) alt_up_ps2_write_data_byte_with_ack (PS2_dev, 0xF4);
	alt_up_ps2_read_data_byte (PS2_dev, &PS2_read1);
	if (PS2_read1 == 0xFA)
		alt_printf ("Enabled interrupts of PS2 port\n");
	else {
		alt_printf ("Error: could not enable interrupts of PS2 port\n");
		return -1;
	}

	// open the audio port
	audio_dev = alt_up_audio_open_dev ("/dev/Audio");
	if ( audio_dev == NULL)
	{
		alt_printf ("Error: could not open audio device\n");
		return -1;
	}
	else
	{
		alt_printf ("Opened audio device\n");
		up_dev.audio_dev = audio_dev;	// store for use by ISRs
	}

	// open the 16x2 character display port
	lcd_dev = alt_up_character_lcd_open_dev ("/dev/Char_LCD_16x2");
	if ( lcd_dev == NULL)
	{
		alt_printf ("Error: could not open character LCD device\n");
		return -1;
	}
	else
	{
		alt_printf ("Opened character LCD device\n");
		up_dev.lcd_dev = lcd_dev;	// store for use by ISRs
	}

	/* use the HAL facility for registering interrupt service routines. */
	/* Note: we are passsing a pointer to up_dev to each ISR (using the context argument) as 
	 * a way of giving the ISR a pointer to every open device. This is useful because some of the
	 * ISRs need to access more than just one device (e.g. the pushbutton ISR accesses both
	 * the pushbutton device and the audio device) */
	alt_irq_register (0, (void *) &up_dev, (void *) interval_timer_ISR);
	alt_irq_register (1, (void *) &up_dev, (void *) pushbutton_ISR);
	alt_irq_register (6, (void *) &up_dev, (void *) audio_ISR);
	alt_irq_register (7, (void *) &up_dev, (void *) PS2_ISR);

	/* create a messages to be displayed on the VGA and LCD displays */
	char text_top_LCD[80] = "Welcome to the DE2 Media Computer...\0";
	char text_button_left_VGA[10] = "Record";
	char text_button_right_VGA[10] = "Play";
	char text_line_VGA[15] = "Audio Plot";

	/* output text message to the LCD */
	alt_up_character_lcd_set_cursor_pos (lcd_dev, 0, 0);	// set LCD cursor location to top row
	alt_up_character_lcd_string (lcd_dev, text_top_LCD);
	alt_up_character_lcd_cursor_off (lcd_dev);				// turn off the LCD cursor 

	/* open the pixel buffer */
	pixel_buffer_dev = alt_up_pixel_buffer_dma_open_dev ("/dev/VGA_Pixel_Buffer");
	if ( pixel_buffer_dev == NULL)
		alt_printf ("Error: could not open pixel buffer device\n");
	else
		alt_printf ("Opened pixel buffer device\n");

	// fill the screen
	alt_up_pixel_buffer_dma_draw_box (pixel_buffer_dev, 0, 0, screen_x, screen_y, screen_color, 0);

	// character coords * 4 since characters are 4 x 4 pixel buffer coords (8 x 8 VGA coords)
	alt_up_pixel_buffer_dma_draw_box (pixel_buffer_dev, x11, y11, x12, y12, box_color, 0);
	alt_up_pixel_buffer_dma_draw_box (pixel_buffer_dev, x21, y21, x22, y22, box_color, 0);
	alt_up_pixel_buffer_dma_draw_box (pixel_buffer_dev, 10, 73, 310, 75, line_color, 0);
	alt_up_pixel_buffer_dma_draw_box (pixel_buffer_dev, 10, 217, 310, 219, line_color, 0);

	/* output text message in the middle of the VGA monitor */
	char_buffer_dev = alt_up_char_buffer_open_dev ("/dev/VGA_Char_Buffer");
	if ( char_buffer_dev == NULL)
		alt_printf ("Error: could not open character buffer device\n");
	else
		alt_printf ("Opened character buffer device\n");

	// write labels in boxes
	alt_up_char_buffer_string (char_buffer_dev, text_button_left_VGA, x11 / 4 + 10, y11 / 4 + 5);
	alt_up_char_buffer_string (char_buffer_dev, text_button_right_VGA, x21 / 4 + 11, y21 / 4 + 5);
	alt_up_char_buffer_string (char_buffer_dev, text_line_VGA, 40 - 5, 17);

	/* this loops "bounces" the word ALTERA around on the VGA screen */
	while (1)
	{
		// wait to synchronize with timeout, which is set by the interval timer ISR
		while (!timeout);

		// calculate and display average of sound
		if (record_flag) {
			//calc_sum();
			amplitude_circute_stop();
			amplitude_circute_set_num(N);
			amplitude_circute_set_size(BUF_SIZE / N);
			amplitude_circute_set_rbuff_addr((int) r_buf);
			amplitude_circute_set_lbuff_addr((int) l_buf);
			amplitude_circute_set_dest_addr((int) sum);
			amplitude_circute_start();
			while(!amplitude_circute_get_status());
			for(i = 0; i < N; i++) {
				average[i] = sum[i] / (2 * BUF_SIZE / N);
			}
			display_average(pixel_buffer_dev);
			record_flag = 0;
		}

		// display movement in time of sound
		if (status) {
			display_movement(pixel_buffer_dev);
			if (status == 20)
				status = 0;
		}

		// do something if mouse data is ready
		if(f) {
			// save bytes
			b1 = byte1;
			b2 = byte2;
			b3 = byte3;

			// compute dx and dy
			if(b2 < 128)
				dx = b2;
			else
				dx = b2 - 256;
			if(b3 < 128)
				dy = b3;
			else
				dy = b3 - 256;

			// update mouse coordinates
			old_mouse_x = mouse_x;
			old_mouse_y = mouse_y;
			if(0 <= (mouse_x + C * dx) && (mouse_x + C * dx) <= 319)
				mouse_x += C * dx;
			if(0 <= (mouse_y - C * dy) && (mouse_y - C * dy) <= 69)
				mouse_y -= C * dy;

			// determining old_mouse_color
			old_mouse_color = screen_color;
			if((x11 <= old_mouse_x && (old_mouse_x + W) <= x12) && (y11 <= old_mouse_y && (old_mouse_y + W) <= y12)) old_mouse_color = box_color;
			if((x21 <= old_mouse_x && (old_mouse_x + W) <= x22) && (y21 <= old_mouse_y && (old_mouse_y + W) <= y22)) old_mouse_color = box_color;

			// clear older mouse location and draw newer mouse location
			alt_up_pixel_buffer_dma_draw_box (pixel_buffer_dev, old_mouse_x, old_mouse_y, (old_mouse_x + W), (old_mouse_y + W), old_mouse_color, 0);
			alt_up_pixel_buffer_dma_draw_box (pixel_buffer_dev, mouse_x, mouse_y, (mouse_x + W), (mouse_y + W), mouse_color, 0);
			HEX_LEDR_PS2(&up_dev, b1, b2, b3);

			if((x11 <= mouse_x && (mouse_x + W) <= x12) && (y11 <= mouse_y && (mouse_y + W) <= y12) && (b1 & 0x01)) {
				// reset monitor
				alt_up_pixel_buffer_dma_draw_box (pixel_buffer_dev, 0, 75, screen_x, 215, screen_color, 0);
				alt_up_pixel_buffer_dma_draw_box (pixel_buffer_dev, 0, 221, screen_x, screen_y, screen_color, 0);
				// reset status
				status = 0;
				// reset the buffer index for recording
				buf_index_record = 0;
				// clear audio FIFOs
				alt_up_audio_reset_audio_core (audio_dev);
				// enable audio-in interrupts
				alt_up_audio_enable_read_interrupt (audio_dev);
			}

			if((x21 <= mouse_x && (mouse_x + W) <= x22) && (y21 <= mouse_y && (mouse_y + W) <= y22) && (b1 & 0x01)) {
				// reset monitor
				alt_up_pixel_buffer_dma_draw_box (pixel_buffer_dev, 0, 221, screen_x, screen_y, screen_color, 0);
				// reset status
				status = 0;
				// reset counter to start play
				buf_index_play = 0;
				// clear audio FIFOs
				alt_up_audio_reset_audio_core (audio_dev);
				// enable audio-out interrupts
				alt_up_audio_enable_write_interrupt (audio_dev);
			}

			//reset f
			f = 0;
		}
		timeout = 0;
	}
}

/****************************************************************************************
 * Subroutine to show a string of HEX data on the HEX displays
 * Note that we are using pointer accesses for the HEX displays parallel port. We could
 * also use the HAL functions for these ports instead
****************************************************************************************/
void HEX_LEDR_PS2(struct alt_up_dev *up_dev, unsigned char b1, unsigned char b2, unsigned char b3)
{
	volatile int *HEX3_HEX0_ptr = (int *) 0x10000020;
	volatile int *HEX7_HEX4_ptr = (int *) 0x10000030;

	/* SEVEN_SEGMENT_DECODE_TABLE gives the on/off settings for all segments in
	 * a single 7-seg display in the DE2 Media Computer, for the hex digits 0 - F */
	unsigned char	seven_seg_decode_table[] = {0x3F, 0x06, 0x5B, 0x4F, 0x66, 0x6D, 0x7D, 0x07, 0x7F, 0x67, 0x77, 0x7C, 0x39, 0x5E, 0x79, 0x71};
	unsigned char	hex_segs[] = { 0, 0, 0, 0, 0, 0, 0, 0 };
	unsigned int shift_buffer, nibble;
	unsigned char code;
	int i;

	shift_buffer = (b2 << 16) | b3;
	for ( i = 0; i < 6; ++i )
	{
		nibble = shift_buffer & 0x0000000F;		// character is in rightmost nibble
		code = seven_seg_decode_table[nibble];
		hex_segs[i] = code;
		shift_buffer = shift_buffer >> 4;
	}

	/* drive the hex displays */
	*(HEX3_HEX0_ptr) = *(int *) (hex_segs);
	*(HEX7_HEX4_ptr) = *(int *) (hex_segs+4);

	alt_up_parallel_port_write_data (up_dev->red_LEDs_dev, (0x07 & b1)); // set LEDR[2..0] on or off
}
void calc_sum()
{
	int i, j;
	unsigned long long int mysum;

	for(i = 0; i < N; i++) {
		mysum = 0;
		for(j = i * (BUF_SIZE / N); j < (i + 1) * (BUF_SIZE / N); j++) {
			if(r_buf[j] >= 0)
				mysum += r_buf[j];
			else
				mysum -= r_buf[j];
		}
		for(j = i * (BUF_SIZE / N); j < (i + 1) * (BUF_SIZE / N); j++) {
			if(l_buf[j] >= 0)
				mysum += l_buf[j];
			else
				mysum -= l_buf[j];
		}
		sum[i] = mysum;
	}
}
void display_average(alt_up_pixel_buffer_dma_dev *pixel_buffer_dev)
{
	int i;
	int L = 300 / N, h;

	for(i = 0; i < N; i++) {
		h = average[i] / 2147483647.0 * 140;
		alt_up_pixel_buffer_dma_draw_box (pixel_buffer_dev, i * L + 10, 215 - h, (i + 1) * L + 8, 215, average_bar_color, 0);
	}
}
void display_movement(alt_up_pixel_buffer_dma_dev *pixel_buffer_dev)
{
	int L = 300 / N;

	alt_up_pixel_buffer_dma_draw_box (pixel_buffer_dev, (status - 1) * L + 10, 234, status * L + 8, 221, movement_bar_color, 0);
}
